package main

import (
	"fmt"
	"github.com/ziyadparekh/libaddress/generator/addressor"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sort"
	"strings"
	"time"
)

func main() {
	fmt.Println(
		"Downloading address data from %s."+
			"This may take a few minutes.\n",
		addressor.GOOGLE_ADDRESS_URL,
	)

	start := time.Now()

	url := fmt.Sprintf("%s/data", addressor.GOOGLE_ADDRESS_URL)
	data, err := http.Get(url)
	if err != nil {
		log.Fatalf(
			"error getting countries from endpoint: %s",
			err.Error(),
		)
	}

	if data.StatusCode != http.StatusOK {
		log.Fatalf(
			"error getting countries from endpoint,"+
				"error code %d",
			data.StatusCode,
		)
	}

	ecs, err := addressor.DecodeCountries(data.Body)
	if err != nil {
		log.Fatalf(
			"error unmarshaling countries JSON: %s",
			err.Error(),
		)
	}

	countries := strings.Split(ecs.Countries, "~")
	// Include the fallback ZZ (unknown) country
	countries = append(countries, "ZZ")

	ccCh := make(chan string, len(countries))
	stopCh := make(chan struct{})
	resCh := make(chan addressor.Result)

	for i := 0; i < addressor.NUM_WORKERS; i++ {
		w := &addressor.Worker{
			CC:   ccCh,
			Stop: stopCh,
			Res:  resCh,
		}

		w.Start()
	}

	for _, country := range countries {
		ccCh <- country
	}

	processedCountries := make(map[string]addressor.Country)
	fmt.Println("Processed:")

	for i := 0; i < len(countries); i++ {
		result, ok := <-resCh
		if !ok {
			break
		}

		if result.Error != nil {
			close(stopCh)
			log.Fatalf(
				"Error processing country: %s",
				result.Error.Error(),
			)
		}

		fmt.Printf("%s\n", result.Country.ID)
		processedCountries[result.Country.ID] = result.Country
	}

	// Order the countries by ID so that the order of the generated
	// countries will be deterministic. This prevents huge diffs
	// when updating the data.
	var sortedCountries []string
	for id := range processedCountries {
		sortedCountries = append(sortedCountries, id)
	}
	sort.Strings(sortedCountries)

	fmt.Println("\nGenerating code...")
	generated := `
		// Code generated by libaddress. DO NOT EDIT.
		package libaddress
		
		var generated = data{
	`

	for _, country := range sortedCountries {
		generated += fmt.Sprintf(
			`"%s":%s,`,
			country,
			processedCountries[country].ToCode(),
		)
	}

	generated += `}`

	fmt.Println("Formatting generated code...")

	formatted, err := format.Source([]byte(generated))
	if err != nil {
		log.Fatalf("Error formatting generated source: %s", err.Error())
	}

	err = ioutil.WriteFile("data.generated.go", formatted, os.ModePerm)

	if err != nil {
		log.Fatalf("Error writing data.go: %s", err.Error())
	}

	timeTaken := time.Since(start)

	fmt.Printf("Total time taken: %s\n", timeTaken)
}
